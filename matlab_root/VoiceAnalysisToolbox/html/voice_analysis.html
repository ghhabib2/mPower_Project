
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>voice_analysis</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-03-31"><meta name="DC.source" content="voice_analysis.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">MAIN Function of the Toolbox -- calculate various patterns from the voice signals: ONLY TESTED WITH THE SUSTAINED VOWEL /a/</a></li><li><a href="#4">Inputs: data         -&gt; Speech signal (vector) OR *.wav file</a></li><li><a href="#5">Parameter initialization</a></li><li><a href="#6">Feature extraction</a></li><li><a href="#8">Additional functions</a></li><li><a href="#10">Calculate the PQ using the classical PQ formula</a></li><li><a href="#14">HNR computation process</a></li><li><a href="#16">Summarize data</a></li><li><a href="#18">Calculate the glottis quotients</a></li><li><a href="#21">Use classical EMD</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [measures_vector, measures_names, F0] = voice_analysis(data, fs, f0_alg)
</pre><pre class="codeinput"><span class="comment">%</span>
<span class="comment">% General call: [dysphonia_measures, dysphonia_measures_names, F0] = voice_analysis(data, fs);</span>
<span class="comment">%           OR: [dysphonia_measures, dysphonia_measures_names, F0] = voice_analysis('thanasis_aahh.wav');</span>
<span class="comment">%</span>
<span class="comment">% Note that some *.wav files may occasionally have a slightly different</span>
<span class="comment">% format than the one that Matlab supports. In that case, simply read the</span>
<span class="comment">% file and provide the speech signal "data" and the sampling frequency "fs"</span>
<span class="comment">%</span>
</pre><h2 id="3">MAIN Function of the Toolbox -- calculate various patterns from the voice signals: ONLY TESTED WITH THE SUSTAINED VOWEL /a/</h2><p>Main function of the "Voice Analysis Toolbox"</p><p>- Function which calculates various characteristics of the signal, also   known as "dysphonia measures" - The function also computes the fundamental frequency (F0) of the signal</p><h2 id="4">Inputs: data         -&gt; Speech signal (vector) OR *.wav file</h2><pre>        fs           -&gt; Sampling frequency (Hz)</pre><pre class="codeinput"><span class="comment">%__________________________________________________________________________</span>
<span class="comment">% optional inputs:</span>
<span class="comment">%          f0_alg       -&gt; Select the algorithm for computing F0</span>
<span class="comment">%                          'SHRP'   - Sun's algorithm</span>
<span class="comment">%                          'SWIPE'  - SWIPE algorithm (A. Camacho)</span>
<span class="comment">% If the user has not downloaded the external functions SHRP and SWIPE, I</span>
<span class="comment">% use a version of PRAAT I built in Matlab                                  [default]</span>
<span class="comment">% =========================================================================</span>
<span class="comment">% Outputs:</span>
<span class="comment">%       measures_vector -&gt; Dysphonia measures in convenient vector format</span>
<span class="comment">%       measures_names  -&gt; Corresponding names for each entry in the</span>
<span class="comment">%                          "measures_vector"</span>
<span class="comment">%               F0      -&gt; Vector with the fundamental frequency assessment</span>
<span class="comment">%                          every 10 milli-seconds</span>
<span class="comment">% =========================================================================</span>
<span class="comment">%</span>
<span class="comment">% Part of the "Voice Analysis Toolbox"</span>
<span class="comment">%</span>
<span class="comment">% -----------------------------------------------------------------------</span>
<span class="comment">% Useful references:</span>
<span class="comment">%</span>
<span class="comment">% [1] A. Tsanas: "Accurate telemonitoring of Parkinson's disease symptom</span>
<span class="comment">%     severity using nonlinear speech signal processing and statistical</span>
<span class="comment">%     machine learning", D.Phil. thesis, University of Oxford, 2012</span>
<span class="comment">%</span>
<span class="comment">% [2] A. Tsanas, M.A. Little, P.E. McSharry, L.O. Ramig: "Nonlinear speech</span>
<span class="comment">%     analysis algorithms mapped to a standard metric achieve clinically</span>
<span class="comment">%     useful quantification of average Parkinson&#146;s disease symptom severity",</span>
<span class="comment">%     Journal of the Royal Society Interface, Vol. 8, pp. 842-855, June 2011</span>
<span class="comment">%</span>
<span class="comment">% [3] A. Tsanas, M.A. Little, P.E. McSharry, L.O. Ramig: "New nonlinear</span>
<span class="comment">%     markers and insights into speech signal degradation for effective</span>
<span class="comment">%     tracking of Parkinson&#146;s disease symptom severity", International</span>
<span class="comment">%     Symposium on Nonlinear Theory and its Applications (NOLTA),</span>
<span class="comment">%     pp. 457-460, Krakow, Poland, 5-8 September 2010</span>
<span class="comment">%</span>
<span class="comment">% [4] A. Tsanas, M.A. Little, P.E. McSharry, L.O. Ramig: &#147;Enhanced classical</span>
<span class="comment">%     dysphonia measures and sparse regression for telemonitoring of</span>
<span class="comment">%     Parkinson's disease progression&#148;, IEEE Signal Processing Society,</span>
<span class="comment">%     International Conference on Acoustics, Speech and Signal Processing</span>
<span class="comment">%     (ICASSP), pp. 594-597, Dallas, Texas, US, 14-19 March 2010</span>
<span class="comment">%</span>
<span class="comment">% [5] A. Tsanas, M.A. Little, C. Fox, L.O. Ramig: "Objective automatic</span>
<span class="comment">%     assessment of rehabilitative speech treatment in Parkinson&#146;s disease",</span>
<span class="comment">%     IEEE Transactions on Neural Systems and Rehabilitation Engineering,</span>
<span class="comment">%     Vol. 22, pp. 181-190, January 2014</span>
<span class="comment">%</span>
<span class="comment">% [6] A. Tsanas: "Automatic objective biomarkers of neurodegenerative</span>
<span class="comment">%     disorders using nonlinear speech signal processing tools", 8th</span>
<span class="comment">%     International Workshop on Models and Analysis of Vocal Emissions for</span>
<span class="comment">%     Biomedical Applications (MAVEBA), pp. 37-40, Florence, Italy, 16-18</span>
<span class="comment">%     December 2013</span>
<span class="comment">% -----------------------------------------------------------------------</span>
<span class="comment">%</span>
<span class="comment">% Last modified on 7 March 2014</span>
<span class="comment">%</span>
<span class="comment">% Copyright (c) Athanasios Tsanas, 2014</span>
<span class="comment">%</span>
<span class="comment">% ********************************************************************</span>
<span class="comment">% If you use this program please cite:</span>
<span class="comment">%</span>
<span class="comment">% 1) A. Tsanas, M. Little, P. McSharry and L. Ramig: "Nonlinear speech</span>
<span class="comment">%    analysis algorithms mapped to a standard metric achieve clinically</span>
<span class="comment">%    useful quantification of average Parkinson&#146;s disease symptom severity",</span>
<span class="comment">%    Journal of the Royal Society Interface, Vol. 8, pp. 842-855, June 2011</span>
<span class="comment">%</span>
<span class="comment">% 2) A. Tsanas: "Accurate telemonitoring of Parkinson's disease symptom</span>
<span class="comment">%    severity using nonlinear speech signal processing and statistical</span>
<span class="comment">%    machine learning", D.Phil. thesis, University of Oxford, 2012</span>
<span class="comment">%</span>
<span class="comment">% 3) A. Tsanas: "Automatic objective biomarkers of neurodegenerative</span>
<span class="comment">%    disorders using nonlinear speech signal processing tools", 8th</span>
<span class="comment">%    International Workshop on Models and Analysis of Vocal Emissions for</span>
<span class="comment">%    Biomedical Applications (MAVEBA), pp. 37-40, Florence, Italy, 16-18</span>
<span class="comment">%    December 2013</span>
<span class="comment">% ********************************************************************</span>
<span class="comment">%</span>
<span class="comment">% For any question, to report bugs, or just to say this was useful, email</span>
<span class="comment">% tsanasthanasis@gmail.com</span>
<span class="comment">%</span>
</pre><h2 id="5">Parameter initialization</h2><pre class="codeinput">warning <span class="string">off</span> <span class="string">all</span>

addpath(genpath(pwd))

<span class="keyword">if</span> nargin&lt;3 || isempty(f0_alg)
    f0_alg = <span class="string">'SWIPE'</span>;
<span class="keyword">end</span>

<span class="keyword">if</span>(nargin==1) <span class="comment">% if only one input is provided</span>
    [pathstr, name, ext] = fileparts(data);
    <span class="keyword">if</span>(strcmp(ext, <span class="string">'.wav'</span>)) <span class="comment">% a wav file was included as input; read data</span>
        [data,fs] = wavread(data);
    <span class="keyword">else</span>
        error(<span class="string">'You must provide a valid *.wav file or a vector with the speech signal and the sampling frequency!'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Default params for DFA</span>
Tmax = 1000;
d = 4; <span class="comment">% Embedding dimension</span>
tau = 50; <span class="comment">% Embedding delay</span>
eta = 0.2; <span class="comment">% RPDE close returns radius</span>
dfa_scaling = (50:20:200)'; <span class="comment">% DFA scaling range</span>

f0min = 50; <span class="comment">% min F0 possible --- Adjust depending on application!</span>
f0max = 500; <span class="comment">% max F0 possible --- Adjust depending on application!</span>
flag = 1;

<span class="comment">% pre-process data</span>
data = data - mean(data);
data = data/max(abs(data));

<span class="comment">% Use your favourite tool for estimating the fundamental frequency</span>
<span class="keyword">switch</span> (f0_alg)
    <span class="keyword">case</span> <span class="string">'SHRP'</span>
        <span class="keyword">if</span> (exist(<span class="string">'shrp.m'</span>))
            <span class="comment">% Sun's implementation -&gt; interested in F0</span>
            F0 = shrp(data, fs, [f0min, f0max], 10);
        <span class="keyword">else</span>
            disp(<span class="string">'SHRP not downloaded; using alternative F0 estimator instead'</span>);
            F0 = F0_Thanasis(data,fs); <span class="comment">% avoid problems if the user has not downloaded the SWIPE algorithm</span>
        <span class="keyword">end</span>

    <span class="keyword">case</span> <span class="string">'SWIPE'</span>
        <span class="keyword">if</span> (exist(<span class="string">'swipep.m'</span>))
            <span class="comment">% SWIPE algorithm</span>
            F0 = swipep(data, fs, [f0min, f0max], 0.01);
        <span class="keyword">else</span>
            disp(<span class="string">'SWIPE not downloaded; using alternative F0 estimator instead'</span>);
            F0 = F0_Thanasis(data,fs); <span class="comment">% avoid problems if the user has not downloaded the SWIPE algorithm</span>
        <span class="keyword">end</span>

    <span class="keyword">otherwise</span>
        error(<span class="string">'You must specify an appropriate F0 estimation algorithm!'</span>)
<span class="keyword">end</span>

<span class="keyword">if</span> (exist(<span class="string">'dypsa.m'</span>))
    <span class="comment">% Work with dypsa</span>
    [VF_close, VF_open] = dypsa(data,fs);
    <span class="comment">% get A0</span>
    N=length(VF_close);
    <span class="keyword">for</span> i=1:N-1
        A0(i) = max(abs(data(VF_open(i):VF_close(i+1))));
    <span class="keyword">end</span>
<span class="keyword">else</span>
    data_buffered = buffer(data,0.01*fs);
    A0 = max(data_buffered); <span class="comment">%max value every 10 msec</span>
<span class="keyword">end</span>

data1=data; <span class="comment">% for safety!</span>
measures_names = []; <span class="comment">%this will be set later!</span>
</pre><pre class="codeoutput error">Not enough input arguments.

Error in voice_analysis (line 130)
data = data - mean(data);
</pre><h2 id="6">Feature extraction</h2><pre class="codeinput"><span class="comment">% jitter variants</span>
[Jitter] = jitter_shimmer(F0);
<span class="comment">% [Jitter2] = jitter_shimmer(1/F0); % work with pitch -- my JRSI2011 paper</span>
<span class="comment">% demonstrated this does not really add additional information to jitter</span>
<span class="comment">% measures when simply using the F0 contour (at least for PD applications)</span>

<span class="comment">% shimmer variants</span>
[Shimmer] = jitter_shimmer(A0);

<span class="comment">% Harmonics to Noise Ratio (HNR) and Noise to Harmonics Ratio (NHR)</span>
[HNR,NHR] = HNRFun(data,fs);

<span class="comment">% DFA</span>
<span class="keyword">if</span> (exist(<span class="string">'fastdfa.m'</span>))
    dfa = fastdfa(data, dfa_scaling);
    DFA = 1/(1+exp(-dfa));
<span class="keyword">else</span>
    DFA = NaN;
<span class="keyword">end</span>

<span class="comment">%RPDE</span>
<span class="keyword">if</span> (exist(<span class="string">'rpde.m'</span>))
    data_resampled = resample(data, 25000, fs);<span class="comment">% Resample to analysis rate</span>
    RPDE = rpde(data_resampled, d, tau, eta, Tmax); <span class="comment">%single element vector</span>
<span class="keyword">else</span>
    RPDE = NaN;
<span class="keyword">end</span>

<span class="comment">% PPE2 (improved version compared to Max's)</span>
F0mean_healthy_control = 120; <span class="comment">% mean(F0); % strictly speaking, adjust this for healthy controls males = 120 and females = 190</span>
logF0signal = log_bb(F0/F0mean_healthy_control); <span class="comment">% log transform F0 is beneficial - see my ICASSP2010 paper, also controlling for F0 in healthy controls</span>
ARcoef = arcov(logF0signal, 10); <span class="comment">% identify AR coefficients</span>
sig_filtered = filter(ARcoef, 1, logF0signal);
sig_filtered = sig_filtered(round(0.001*fs):end);
<span class="comment">% Obtain measure of dispersion - use simple histogramic means for now</span>
PPEd = hist(sig_filtered, linspace(min(sig_filtered), max(sig_filtered), 100));
PPE = H_entropy(PPEd/sum(PPEd))/log_bb(length(PPEd));

<span class="comment">% Glottis open/closed quotient [Glottis Quotient (GQ) in the JRSI paper]</span>
<span class="keyword">if</span> (exist(<span class="string">'dypsa.m'</span>))
    [GQ] = glottis_quotient(VF_close,VF_open, fs, f0min, f0max, flag);
<span class="keyword">else</span>
    GQ = NaN*ones(1,3);
<span class="keyword">end</span>

<span class="comment">% Glottal to Noise Excitation (GNE) related measures</span>
[GNE] = GNE_measure(data,fs);

<span class="comment">% Vocal Fold Excitation Ratios (VFER) in the JRSI2011 paper</span>
<span class="keyword">if</span> (exist(<span class="string">'dypsa.m'</span>))
    [VFER] = VFER_measure(data,fs);
<span class="keyword">else</span>
    VFER = NaN*ones(1,7);
<span class="keyword">end</span>

<span class="comment">% Empirical Mode Decomposition Excitations Ratios (EMD-ER) in the JRSI paper</span>
<span class="keyword">if</span> (exist(<span class="string">'emd.m'</span>))
    [EMD_ER] = IMF_measure(data1);
<span class="keyword">else</span>
    EMD_ER = NaN*ones(1,6);
<span class="keyword">end</span>

<span class="comment">% MFCCs</span>
<span class="keyword">if</span> (exist(<span class="string">'melcepst.m'</span>))
    mfcc = melcepst(data, fs, <span class="string">'E0dD'</span>);
    MFCCs_mean = mean(mfcc);
    MFCCs_std = std(mfcc);
<span class="keyword">else</span>
    MFCCs_mean = NaN*ones(1,42);
    MFCCs_std = NaN*ones(1,42);
<span class="keyword">end</span>

<span class="comment">% Wavelet measures (my NOLTA2010 paper)</span>
[wavelet_features, wavelet_feature_names] = wavedec_features(F0);

<span class="comment">% Summarize ALL dysphonia measures in a single vector</span>
measures_vector = [Jitter, Shimmer, HNR, NHR, GQ, GNE, VFER, EMD_ER, MFCCs_mean, MFCCs_std, wavelet_features, PPE, DFA, RPDE];

<span class="comment">% Get the names of the variables correctly</span>
load (<span class="string">'measures_names.mat'</span>)
</pre><pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of main function</span>

<span class="comment">%==========================================================================</span>
<span class="comment">%==========================================================================</span>
</pre><h2 id="8">Additional functions</h2><pre class="codeinput"><span class="keyword">function</span> [measures] = jitter_shimmer(A0)

mean_Ampl = mean(A0);

<span class="comment">% Mean absolute difference of successive cycles</span>
measures(1) = mean(abs(diff(A0)));

<span class="comment">% Mean absolute difference of successive cycles - expressed in percent (%)</span>
measures(2) = 100*mean(abs(diff(A0)))/mean_Ampl;

<span class="comment">% Perturbation quotient</span>
[Ampl_PQ3] = perq1(A0,3);
measures(3) = Ampl_PQ3.classical_Schoentgen;
measures(4) = Ampl_PQ3.classical_Baken;
measures(5) = Ampl_PQ3.generalised_Schoentgen;

[Ampl_PQ5]=perq1(A0,5); <span class="comment">% Use 5 cycle samples (Schoentgen)</span>
measures(6)=Ampl_PQ5.classical_Schoentgen;
measures(7)=Ampl_PQ5.classical_Baken;
measures(8)=Ampl_PQ5.generalised_Schoentgen;

[Ampl_PQ11]=perq1(A0,11); <span class="comment">% Use 11 cycle samples (Schoentgen)</span>
measures(9)=Ampl_PQ11.classical_Schoentgen;
measures(10)=Ampl_PQ11.classical_Baken;
measures(11)=Ampl_PQ11.generalised_Schoentgen;

<span class="comment">% zeroth order perturbation</span>
measures(12) = mean(abs(A0-mean_Ampl));

<span class="comment">% Shimmer(dB)</span>
measures(13) = mean(20*(abs(log10((A0(1:end-1))./(A0(2:end))))));

<span class="comment">% CV</span>
measures(14)=mean((diff(A0)).^2)/(mean_Ampl)^2;

<span class="comment">% TKEO</span>
measures(15) = mean(abs(TKEO(A0)));
measures(16) = std(TKEO(A0));
Ampl_TKEO_prc = prctile(TKEO(A0),[5 25 50 75 95]);
measures(17)=Ampl_TKEO_prc(1);
measures(18)=Ampl_TKEO_prc(2);
measures(19)=Ampl_TKEO_prc(3);
measures(20)=Ampl_TKEO_prc(4);

<span class="comment">% AM</span>
measures(21) = (max(A0)-min(A0))/(max(A0)+min(A0));

measures(22) = Ampl_TKEO_prc(4) - Ampl_TKEO_prc(1);
<span class="keyword">end</span>

<span class="keyword">function</span> PQ = perq1(time_series, K)
</pre><h2 id="10">Calculate the PQ using the classical PQ formula</h2><pre class="codeinput">N = length(time_series);
mean_tseries = mean(time_series);
K1=round(K/2);
K2=K-K1;
p = 5;
sum1=0;

<span class="keyword">for</span> i = K1:N-K2
    sum1 = sum1+mean(abs([time_series(i-K2:i+K2)]-time_series(i)));
<span class="keyword">end</span>

PQ.classical_Schoentgen = (sum1/(N-K+1))/(mean_tseries);

sum2=0;
<span class="keyword">for</span> i = K1:N-K2
    sum2 = sum2+mean(abs([time_series(i-K2:i+K2)]))-time_series(i);
<span class="keyword">end</span>

PQ.classical_Baken = (sum2/(N-K+1))/(mean_tseries);

<span class="comment">% perturbation quotient of the residue</span>
time_series=time_series(:);
sum3=0;
<span class="comment">% calculate the AR coefficients (I use the Yule-Walker equations)</span>
new_tseries=(time_series-mean_tseries)';
a = aryule(time_series-mean_tseries,p);

<span class="keyword">for</span> i = 1+p:N
    sum3 = sum3+abs(sum(a.*(new_tseries(i:-1:i-p))));
<span class="keyword">end</span>

PQ.generalised_Schoentgen = (sum3/(N-p))/(mean_tseries);
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [HNR, NHR] = HNRFun(data,fs)
</pre><pre class="codeinput">f0max=500; <span class="comment">%Hz -- max value, possibly adjust for other applications</span>
f0min=50; <span class="comment">%Hz</span>
tstep=0.01*fs;
x=0.08*fs;
steps=(length(data)-x)/tstep;

<span class="keyword">for</span> i=1:steps
</pre><pre class="codeinput">    tseries = data(i*tstep:i*tstep+x);
    tseries = tseries-mean(tseries);
    Dwindow = hann(length(tseries));
    segment_sig = tseries.*Dwindow;
</pre><h2 id="14">HNR computation process</h2><pre class="codeinput">    ACF = xcorr(segment_sig,<span class="string">'coeff'</span>);
    ACF2 = ACF(length(segment_sig):end);
    aa=fft(segment_sig);
    aa=ifft(abs(aa).^2);
    ACF_Dwindow = xcorr(Dwindow,<span class="string">'coeff'</span>);
    ACF_Dwindow2 = ACF_Dwindow(length(Dwindow):end);
    bb=fft(Dwindow);
    bb=ifft(abs(bb).^2);
    ACF_signal = ACF2./ACF_Dwindow2;
    ACF_signal = ACF_signal(1:round(length(ACF_signal)/3));
    rho=aa./bb;
    rho=rho(1:length(rho)/2);
    rho=rho/max(rho);
    [rx_value,rx_index] = sort(ACF_signal,<span class="string">'descend'</span>);
    [d1 d2] = sort(rho, <span class="string">'descend'</span>);
    low_lim=ceil(fs/f0max);  <span class="comment">% round towards positive sample number</span>
    up_lim=floor(fs/f0min);  <span class="comment">% round towards negative sample number</span>
    k=2;
    <span class="keyword">while</span> ((rx_index(k)&lt;low_lim) || rx_index(k)&gt;up_lim)
        k=k+1;
    <span class="keyword">end</span>

    m=2;
    <span class="keyword">while</span> ((d2(m)&lt;low_lim) || d2(m)&gt;up_lim)
        m=m+1;
    <span class="keyword">end</span>
    ll(i)=d2(m);
    mm=d2(m);
    HNR_dB_Praat(i) = 10*log10(rho(mm)/(1-rho(mm)));
    NHR_Praat(i) = (1-rho(mm))/rho(mm);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="16">Summarize data</h2><pre class="codeinput">HNR(1)=mean(HNR_dB_Praat);
HNR(2)=std(HNR_dB_Praat);

NHR(1)=mean(NHR_Praat);
NHR(2)=std(NHR_Praat);
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [GQ] = glottis_quotient(VF_close, VF_open, fs, f0min, f0max, flag)
</pre><h2 id="18">Calculate the glottis quotients</h2><pre class="codeinput">cycle_open=abs(VF_open(2:end)-VF_close(1:end-1));
cycle_closed=abs(VF_open(1:end-1)-VF_close(1:end-1));

<span class="comment">% remove erroneous cycles</span>
<span class="keyword">if</span> flag
    low_lim=fs/f0max; <span class="comment">% lower limit</span>
    up_lim=fs/f0min;  <span class="comment">% upper limit</span>
    N=length(cycle_open);
    <span class="keyword">for</span> i=1:N-1
        <span class="keyword">if</span>((cycle_open(i) &gt; up_lim) || (cycle_open(i) &lt; low_lim))
            cycle_open(i)=NaN;
        <span class="keyword">end</span>
        <span class="keyword">if</span>((cycle_closed(i) &gt; up_lim) || (cycle_closed(i) &lt; low_lim))
            cycle_closed(i)=NaN;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%statistics in time</span>
prc1=prctile(cycle_open,[5 95]);
cycle_open_range_5_95_perc=prc1(2)-prc1(1);
prc2=prctile(cycle_closed,[5 95]);
cycle_closed_range_5_95_perc=prc2(2)-prc2(1);

GQ(1) = (cycle_open_range_5_95_perc/(cycle_open_range_5_95_perc+cycle_closed_range_5_95_perc));
GQ(2) = (nanstd(cycle_open));
GQ(3) = (nanstd(cycle_closed));
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [GNE] = GNE_measure(data, fs)

filt_order=100;
new_fs=10000;
x = 0.03*new_fs;
tstep=0.01*new_fs;
BW = 1000; <span class="comment">% bandwidth</span>
Fshift = 500; <span class="comment">% shift fr</span>
data = resample(data, new_fs, fs);

<span class="comment">% cut-off1</span>
Fc1=1:Fshift:(new_fs/2-BW-500); <span class="comment">% not to cross Nq freq!</span>
<span class="comment">% cut-off2</span>
Fc2=Fc1+BW;

<span class="keyword">for</span> j=1:length(Fc1);
    d(j) =fdesign.bandpass(<span class="string">'n,fc1,fc2'</span>,filt_order,Fc1(j),Fc2(j),new_fs);
    hd(j) = design(d(j));
<span class="keyword">end</span>

steps=(length(data)-x)/tstep;

<span class="keyword">for</span> i=1:steps+1
    tseries = data(1+(i-1)*tstep:(i-1)*tstep+x);
    Dwindow = hann(length(tseries));
    segment_sig = tseries.*Dwindow;

    a = lpc(segment_sig,13);
    est_x = filter([0 -a(2:end)],1,segment_sig);    <span class="comment">% Estimated signal</span>
    e = segment_sig - est_x;
    LPE = xcorr(e,<span class="string">'coeff'</span>);   <span class="comment">% LPES</span>
    LPE=LPE(length(LPE)/2:end);

    <span class="keyword">for</span> ii=1:length(hd)
        sigBW(:,ii)=filter(hd(ii),LPE);
        sig_TKEO(ii) = mean(TKEO(sigBW(:,ii)));
        sig_energy(ii) = mean(sigBW(:,ii)).^2;
    <span class="keyword">end</span>
    Hilb_tr = hilbert(sigBW);
    Hilb_env = abs(Hilb_tr);
    c = xcorr(Hilb_env);
    [cval,cidx] = max(c);
    GNEm(i) = max(cval);

    signal_BW_TKEO(i,:) = sig_TKEO;
    signal_BW_energy(i,:) = sig_energy;
<span class="keyword">end</span>

signal_BW_TKEO2 = mean(log(signal_BW_TKEO)); <span class="comment">% used for getting the noise to signal ratio</span>
signal_energy2 = mean(log(signal_BW_energy));

<span class="comment">% Set outputs</span>

GNE(1) = mean(GNEm);
GNE(2) = std(GNEm);

gnTKEO = mean(signal_BW_TKEO);
gnSEO = mean(signal_BW_energy);
GNE(3) = sum(gnTKEO(1:2))/sum(gnTKEO(end-3:end));
GNE(4) = sum(gnSEO(1:2))/sum(gnSEO(end-3:end));
GNE(5) = sum(signal_BW_TKEO2(end-3:end))/sum(signal_BW_TKEO2(1:2));
GNE(6) = sum(signal_energy2(end-3:end))/sum(signal_energy2(1:2));

<span class="keyword">end</span>


<span class="keyword">function</span> [VFER] = VFER_measure(data, fs)

filt_order=100;
BW = 500; <span class="comment">% bandwidth</span>
Fmax = (fs/2-BW-300); <span class="comment">% Max frequency to check</span>
Fshift = 500; <span class="comment">% shift</span>

<span class="comment">% get VF action</span>
[VF_close,VF_open] = dypsa(data,fs);

<span class="comment">% cut-off1</span>
Fc1=1:Fshift:Fmax;
<span class="comment">% cut-off2</span>
Fc2=Fc1+BW;

<span class="keyword">for</span> j=1:length(Fc1);
    d(j) = fdesign.bandpass(<span class="string">'n,fc1,fc2'</span>,filt_order,Fc1(j),Fc2(j),fs);
    hd(j) = design(d(j));
<span class="keyword">end</span>

<span class="keyword">for</span> i=1:length(VF_close)-1
    tseries = data(VF_close(i):VF_close(i+1));
    Dwindow = hann(length(tseries)); <span class="comment">%Use Hanning window</span>
    segment_sig = tseries.*Dwindow;

    <span class="keyword">if</span> (length(tseries)&gt;50)
        <span class="keyword">for</span> ii=1:length(hd)
            thanasis = filter(hd(ii),segment_sig);
            sigBW(:,ii) = thanasis(1:50);
            sig_TKEO(ii) = mean(TKEO(sigBW(:,ii)));
            sig_SEO(ii) = mean(sigBW(:,ii)).^2;
        <span class="keyword">end</span>
        Hilb_tr = hilbert(sigBW);
        Hilb_env = abs(Hilb_tr);
        c = xcorr(Hilb_env);
        [cval,cidx] = max(c);
        NEm(i) = max(cval);

        signal_BW_TKEO(i,:) = sig_TKEO;
        signal_BW_SEO(i,:) = sig_SEO;
    <span class="keyword">end</span>
<span class="keyword">end</span>

signal_BW_TKEO2 = mean(log(signal_BW_TKEO)); <span class="comment">% used for getting the noise to signal ratio</span>

<span class="comment">% Set outputs</span>

VFER(1) = mean(NEm);
VFER(2) = std(NEm);
VFER(3) = -sum(NEm.*log_bb(NEm));
VFTKEO = mean(signal_BW_TKEO);
VFSEO = mean(signal_BW_SEO);
VFlog_SEO = mean(log(signal_BW_SEO));

<span class="comment">% Get 'signal to noise' ratios</span>
VFER(4) = sum(VFTKEO(1:5))/sum(VFTKEO(6:10));
VFER(5) = sum(VFSEO(1:5))/sum(VFSEO(6:10));
VFER(6) = sum(signal_BW_TKEO2(6:10))/sum(signal_BW_TKEO2(1:5));
VFER(7) = sum(VFlog_SEO(6:10))/sum(VFlog_SEO(1:5));

<span class="keyword">end</span>

<span class="keyword">function</span> [IMF] = IMF_measure(data)
</pre><h2 id="21">Use classical EMD</h2><pre class="codeinput">IMF_dec = emd(data);
IMF_dec=IMF_dec';
IMF_dec2=log_bb(IMF_dec); <span class="comment">%Log transformation</span>
[N,M]=size(IMF_dec);

<span class="keyword">for</span> i=1:M
    IMF_decEnergy(i) = abs(mean((IMF_dec(:,i)).^2));
    IMF_decTKEO(i) = abs(mean(TKEO(IMF_dec(:,i))));
    IMF_decEntropia(i) = abs(mean(-sum(IMF_dec(:,i).*log_bb(IMF_dec(:,i)))));
    IMF_decEnergy2(i) = abs(mean((IMF_dec2(:,i)).^2));
    IMF_decTKEO2(i) = abs(mean(TKEO(IMF_dec2(:,i))));
    IMF_decEntropia2(i) = abs(mean(-sum(IMF_dec2(:,i).*log_bb(IMF_dec2(:,i)))));
<span class="keyword">end</span>

<span class="comment">% Get 'signal to noise' ratio measures</span>
IMF(1) = sum(IMF_decEnergy(4:end))/sum(IMF_decEnergy(1:3));
IMF(2) = sum(IMF_decTKEO(4:end))/sum(IMF_decTKEO(1:3));
IMF(3) = sum(IMF_decEntropia(4:end))/sum(IMF_decEntropia(1:3));
IMF(4) = abs(sum(IMF_decEnergy2(1:2))/sum(IMF_decEnergy2(4:end)));
IMF(5) = abs(sum(IMF_decTKEO2(1:2))/sum(IMF_decTKEO2(3:end)));
IMF(6) = sum(IMF_decEntropia2(1:2))/sum(IMF_decEntropia2(3:end));
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [energy] = TKEO(x)

data_length=length(x);
energy=zeros(data_length,1);

energy(1)=(x(1))^2; <span class="comment">% first sample in the vector sequence</span>

<span class="keyword">for</span> n=2:data_length-1
    energy(n)=(x(n))^2-x(n-1)*x(n+1); <span class="comment">% classical TKEO equation</span>
<span class="keyword">end</span>

energy(data_length)=(x(data_length))^2; <span class="comment">% last sample in the vector sequence</span>

<span class="keyword">end</span> <span class="comment">% end of TKEO function</span>

<span class="keyword">function</span> H = H_entropy(f)
<span class="comment">% Calculate entropy of a discrete distribution</span>
<span class="comment">% Usage: H = entropy(f)</span>
<span class="comment">%  f - input distribution as a vector</span>
<span class="comment">%  H - entropy</span>
N = length(f);
H = 0;
<span class="keyword">for</span> j = 1:N
   H = H - f(j) * log_bb(f(j));
<span class="keyword">end</span>

<span class="keyword">end</span> <span class="comment">% end of H_entropy function</span>

<span class="keyword">function</span> pout = log_bb(pin, method)
<span class="comment">% Function that computes the algorithm depending on the user specified</span>
<span class="comment">% base; if the input probability is zero it returns zero.</span>

<span class="keyword">if</span> nargin&lt;2
    method = <span class="string">'Nats'</span>;
<span class="keyword">end</span>

<span class="keyword">switch</span> (method)
    <span class="keyword">case</span> <span class="string">'Hartson'</span> <span class="comment">% using log10 for the entropy computation</span>
        log_b=@log10;

    <span class="keyword">case</span> <span class="string">'Nats'</span> <span class="comment">% using ln (natural log) for the entropy computation</span>
        log_b=@log;

    <span class="keyword">otherwise</span> <span class="comment">% method -&gt; 'Bits' using log2 for the entropy computation</span>
        log_b=@log2;
<span class="keyword">end</span>

<span class="keyword">if</span> pin==0
    pout=0;
<span class="keyword">else</span>
    pout=log_b(pin);
<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
function [measures_vector, measures_names, F0] = voice_analysis(data, fs, f0_alg)
%
% General call: [dysphonia_measures, dysphonia_measures_names, F0] = voice_analysis(data, fs);
%           OR: [dysphonia_measures, dysphonia_measures_names, F0] = voice_analysis('thanasis_aahh.wav');
%
% Note that some *.wav files may occasionally have a slightly different
% format than the one that Matlab supports. In that case, simply read the
% file and provide the speech signal "data" and the sampling frequency "fs"
%
%% MAIN Function of the Toolbox REPLACE_WITH_DASH_DASH calculate various patterns from the voice signals: ONLY TESTED WITH THE SUSTAINED VOWEL /a/
%
% Main function of the "Voice Analysis Toolbox"
%
% - Function which calculates various characteristics of the signal, also
%   known as "dysphonia measures"
% - The function also computes the fundamental frequency (F0) of the signal
%
%% Inputs: data         -> Speech signal (vector) OR *.wav file
%          fs           -> Sampling frequency (Hz)
%__________________________________________________________________________
% optional inputs:  
%          f0_alg       -> Select the algorithm for computing F0
%                          'SHRP'   - Sun's algorithm
%                          'SWIPE'  - SWIPE algorithm (A. Camacho)          
% If the user has not downloaded the external functions SHRP and SWIPE, I
% use a version of PRAAT I built in Matlab                                  [default] 
% =========================================================================
% Outputs: 
%       measures_vector -> Dysphonia measures in convenient vector format
%       measures_names  -> Corresponding names for each entry in the
%                          "measures_vector"
%               F0      -> Vector with the fundamental frequency assessment
%                          every 10 milli-seconds
% =========================================================================
%
% Part of the "Voice Analysis Toolbox"
%
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% Useful references:
% 
% [1] A. Tsanas: "Accurate telemonitoring of Parkinson's disease symptom
%     severity using nonlinear speech signal processing and statistical
%     machine learning", D.Phil. thesis, University of Oxford, 2012
%
% [2] A. Tsanas, M.A. Little, P.E. McSharry, L.O. Ramig: "Nonlinear speech 
%     analysis algorithms mapped to a standard metric achieve clinically 
%     useful quantification of average Parkinsons disease symptom severity", 
%     Journal of the Royal Society Interface, Vol. 8, pp. 842-855, June 2011
%
% [3] A. Tsanas, M.A. Little, P.E. McSharry, L.O. Ramig: "New nonlinear 
%     markers and insights into speech signal degradation for effective 
%     tracking of Parkinsons disease symptom severity", International
%     Symposium on Nonlinear Theory and its Applications (NOLTA), 
%     pp. 457-460, Krakow, Poland, 5-8 September 2010
%
% [4] A. Tsanas, M.A. Little, P.E. McSharry, L.O. Ramig: Enhanced classical
%     dysphonia measures and sparse regression for telemonitoring of 
%     Parkinson's disease progression, IEEE Signal Processing Society, 
%     International Conference on Acoustics, Speech and Signal Processing 
%     (ICASSP), pp. 594-597, Dallas, Texas, US, 14-19 March 2010
%
% [5] A. Tsanas, M.A. Little, C. Fox, L.O. Ramig: "Objective automatic 
%     assessment of rehabilitative speech treatment in Parkinsons disease",
%     IEEE Transactions on Neural Systems and Rehabilitation Engineering, 
%     Vol. 22, pp. 181-190, January 2014
%
% [6] A. Tsanas: "Automatic objective biomarkers of neurodegenerative 
%     disorders using nonlinear speech signal processing tools", 8th 
%     International Workshop on Models and Analysis of Vocal Emissions for 
%     Biomedical Applications (MAVEBA), pp. 37-40, Florence, Italy, 16-18 
%     December 2013 
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%
% Last modified on 7 March 2014
%
% Copyright (c) Athanasios Tsanas, 2014
%
% ********************************************************************
% If you use this program please cite:
%
% 1) A. Tsanas, M. Little, P. McSharry and L. Ramig: "Nonlinear speech
%    analysis algorithms mapped to a standard metric achieve clinically 
%    useful quantification of average Parkinsons disease symptom severity",
%    Journal of the Royal Society Interface, Vol. 8, pp. 842-855, June 2011
%
% 2) A. Tsanas: "Accurate telemonitoring of Parkinson's disease symptom
%    severity using nonlinear speech signal processing and statistical
%    machine learning", D.Phil. thesis, University of Oxford, 2012
%
% 3) A. Tsanas: "Automatic objective biomarkers of neurodegenerative 
%    disorders using nonlinear speech signal processing tools", 8th
%    International Workshop on Models and Analysis of Vocal Emissions for 
%    Biomedical Applications (MAVEBA), pp. 37-40, Florence, Italy, 16-18 
%    December 2013
% ********************************************************************
%
% For any question, to report bugs, or just to say this was useful, email
% tsanasthanasis@gmail.com
%
%% Parameter initialization
warning off all

addpath(genpath(pwd))

if nargin<3 || isempty(f0_alg)
    f0_alg = 'SWIPE'; 
end

if(nargin==1) % if only one input is provided
    [pathstr, name, ext] = fileparts(data);
    if(strcmp(ext, '.wav')) % a wav file was included as input; read data
        [data,fs] = wavread(data);    
    else
        error('You must provide a valid *.wav file or a vector with the speech signal and the sampling frequency!')
    end
end

% Default params for DFA
Tmax = 1000;
d = 4; % Embedding dimension
tau = 50; % Embedding delay
eta = 0.2; % RPDE close returns radius
dfa_scaling = (50:20:200)'; % DFA scaling range

f0min = 50; % min F0 possible REPLACE_WITH_DASH_DASH- Adjust depending on application!
f0max = 500; % max F0 possible REPLACE_WITH_DASH_DASH- Adjust depending on application!
flag = 1;

% pre-process data
data = data - mean(data);
data = data/max(abs(data));

% Use your favourite tool for estimating the fundamental frequency
switch (f0_alg)
    case 'SHRP'
        if (exist('shrp.m'))
            % Sun's implementation -> interested in F0
            F0 = shrp(data, fs, [f0min, f0max], 10);
        else
            disp('SHRP not downloaded; using alternative F0 estimator instead');
            F0 = F0_Thanasis(data,fs); % avoid problems if the user has not downloaded the SWIPE algorithm
        end
        
    case 'SWIPE'
        if (exist('swipep.m'))
            % SWIPE algorithm
            F0 = swipep(data, fs, [f0min, f0max], 0.01);
        else
            disp('SWIPE not downloaded; using alternative F0 estimator instead');
            F0 = F0_Thanasis(data,fs); % avoid problems if the user has not downloaded the SWIPE algorithm
        end
        
    otherwise
        error('You must specify an appropriate F0 estimation algorithm!')
end

if (exist('dypsa.m'))
    % Work with dypsa
    [VF_close, VF_open] = dypsa(data,fs);
    % get A0
    N=length(VF_close);
    for i=1:N-1
        A0(i) = max(abs(data(VF_open(i):VF_close(i+1))));
    end
else
    data_buffered = buffer(data,0.01*fs);
    A0 = max(data_buffered); %max value every 10 msec
end
        
data1=data; % for safety!
measures_names = []; %this will be set later!

%% Feature extraction

% jitter variants
[Jitter] = jitter_shimmer(F0);
% [Jitter2] = jitter_shimmer(1/F0); % work with pitch REPLACE_WITH_DASH_DASH my JRSI2011 paper 
% demonstrated this does not really add additional information to jitter 
% measures when simply using the F0 contour (at least for PD applications)

% shimmer variants
[Shimmer] = jitter_shimmer(A0);

% Harmonics to Noise Ratio (HNR) and Noise to Harmonics Ratio (NHR)
[HNR,NHR] = HNRFun(data,fs);

% DFA 
if (exist('fastdfa.m'))
    dfa = fastdfa(data, dfa_scaling);
    DFA = 1/(1+exp(-dfa));
else
    DFA = NaN;
end

%RPDE
if (exist('rpde.m'))
    data_resampled = resample(data, 25000, fs);% Resample to analysis rate
    RPDE = rpde(data_resampled, d, tau, eta, Tmax); %single element vector
else
    RPDE = NaN;
end

% PPE2 (improved version compared to Max's)
F0mean_healthy_control = 120; % mean(F0); % strictly speaking, adjust this for healthy controls males = 120 and females = 190
logF0signal = log_bb(F0/F0mean_healthy_control); % log transform F0 is beneficial - see my ICASSP2010 paper, also controlling for F0 in healthy controls
ARcoef = arcov(logF0signal, 10); % identify AR coefficients
sig_filtered = filter(ARcoef, 1, logF0signal);
sig_filtered = sig_filtered(round(0.001*fs):end);
% Obtain measure of dispersion - use simple histogramic means for now
PPEd = hist(sig_filtered, linspace(min(sig_filtered), max(sig_filtered), 100));
PPE = H_entropy(PPEd/sum(PPEd))/log_bb(length(PPEd));

% Glottis open/closed quotient [Glottis Quotient (GQ) in the JRSI paper]
if (exist('dypsa.m'))
    [GQ] = glottis_quotient(VF_close,VF_open, fs, f0min, f0max, flag);
else
    GQ = NaN*ones(1,3);
end

% Glottal to Noise Excitation (GNE) related measures
[GNE] = GNE_measure(data,fs);

% Vocal Fold Excitation Ratios (VFER) in the JRSI2011 paper
if (exist('dypsa.m'))
    [VFER] = VFER_measure(data,fs);
else
    VFER = NaN*ones(1,7);
end

% Empirical Mode Decomposition Excitations Ratios (EMD-ER) in the JRSI paper
if (exist('emd.m'))
    [EMD_ER] = IMF_measure(data1);
else
    EMD_ER = NaN*ones(1,6);
end

% MFCCs
if (exist('melcepst.m'))
    mfcc = melcepst(data, fs, 'E0dD');
    MFCCs_mean = mean(mfcc);
    MFCCs_std = std(mfcc);
else
    MFCCs_mean = NaN*ones(1,42);
    MFCCs_std = NaN*ones(1,42);
end

% Wavelet measures (my NOLTA2010 paper)
[wavelet_features, wavelet_feature_names] = wavedec_features(F0);

% Summarize ALL dysphonia measures in a single vector
measures_vector = [Jitter, Shimmer, HNR, NHR, GQ, GNE, VFER, EMD_ER, MFCCs_mean, MFCCs_std, wavelet_features, PPE, DFA, RPDE];

% Get the names of the variables correctly
load ('measures_names.mat')

end % end of main function

%==========================================================================
%==========================================================================
%% Additional functions

function [measures] = jitter_shimmer(A0)

mean_Ampl = mean(A0);

% Mean absolute difference of successive cycles
measures(1) = mean(abs(diff(A0)));

% Mean absolute difference of successive cycles - expressed in percent (%)
measures(2) = 100*mean(abs(diff(A0)))/mean_Ampl;

% Perturbation quotient
[Ampl_PQ3] = perq1(A0,3);
measures(3) = Ampl_PQ3.classical_Schoentgen;
measures(4) = Ampl_PQ3.classical_Baken;
measures(5) = Ampl_PQ3.generalised_Schoentgen;

[Ampl_PQ5]=perq1(A0,5); % Use 5 cycle samples (Schoentgen)
measures(6)=Ampl_PQ5.classical_Schoentgen;
measures(7)=Ampl_PQ5.classical_Baken;
measures(8)=Ampl_PQ5.generalised_Schoentgen;

[Ampl_PQ11]=perq1(A0,11); % Use 11 cycle samples (Schoentgen)
measures(9)=Ampl_PQ11.classical_Schoentgen;
measures(10)=Ampl_PQ11.classical_Baken;
measures(11)=Ampl_PQ11.generalised_Schoentgen;

% zeroth order perturbation
measures(12) = mean(abs(A0-mean_Ampl));

% Shimmer(dB)
measures(13) = mean(20*(abs(log10((A0(1:end-1))./(A0(2:end))))));

% CV
measures(14)=mean((diff(A0)).^2)/(mean_Ampl)^2;

% TKEO
measures(15) = mean(abs(TKEO(A0)));
measures(16) = std(TKEO(A0));
Ampl_TKEO_prc = prctile(TKEO(A0),[5 25 50 75 95]);
measures(17)=Ampl_TKEO_prc(1);
measures(18)=Ampl_TKEO_prc(2);
measures(19)=Ampl_TKEO_prc(3);
measures(20)=Ampl_TKEO_prc(4);

% AM
measures(21) = (max(A0)-min(A0))/(max(A0)+min(A0));

measures(22) = Ampl_TKEO_prc(4) - Ampl_TKEO_prc(1);
end

function PQ = perq1(time_series, K)

%% Calculate the PQ using the classical PQ formula

N = length(time_series);
mean_tseries = mean(time_series);
K1=round(K/2);
K2=K-K1;
p = 5;
sum1=0;

for i = K1:N-K2
    sum1 = sum1+mean(abs([time_series(i-K2:i+K2)]-time_series(i)));
end
        
PQ.classical_Schoentgen = (sum1/(N-K+1))/(mean_tseries);

sum2=0;
for i = K1:N-K2
    sum2 = sum2+mean(abs([time_series(i-K2:i+K2)]))-time_series(i);
end
        
PQ.classical_Baken = (sum2/(N-K+1))/(mean_tseries);

% perturbation quotient of the residue
time_series=time_series(:);
sum3=0;
% calculate the AR coefficients (I use the Yule-Walker equations)
new_tseries=(time_series-mean_tseries)';
a = aryule(time_series-mean_tseries,p);

for i = 1+p:N
    sum3 = sum3+abs(sum(a.*(new_tseries(i:-1:i-p))));
end

PQ.generalised_Schoentgen = (sum3/(N-p))/(mean_tseries);
    
end

function [HNR, NHR] = HNRFun(data,fs)

f0max=500; %Hz REPLACE_WITH_DASH_DASH max value, possibly adjust for other applications
f0min=50; %Hz
tstep=0.01*fs;
x=0.08*fs;
steps=(length(data)-x)/tstep;

for i=1:steps
    
    tseries = data(i*tstep:i*tstep+x);
    tseries = tseries-mean(tseries);
    Dwindow = hann(length(tseries));
    segment_sig = tseries.*Dwindow;
    
    %% HNR computation process
    ACF = xcorr(segment_sig,'coeff');
    ACF2 = ACF(length(segment_sig):end);
    aa=fft(segment_sig);
    aa=ifft(abs(aa).^2);
    ACF_Dwindow = xcorr(Dwindow,'coeff');
    ACF_Dwindow2 = ACF_Dwindow(length(Dwindow):end);
    bb=fft(Dwindow);
    bb=ifft(abs(bb).^2);
    ACF_signal = ACF2./ACF_Dwindow2;
    ACF_signal = ACF_signal(1:round(length(ACF_signal)/3));
    rho=aa./bb;
    rho=rho(1:length(rho)/2);
    rho=rho/max(rho);
    [rx_value,rx_index] = sort(ACF_signal,'descend');
    [d1 d2] = sort(rho, 'descend');
    low_lim=ceil(fs/f0max);  % round towards positive sample number
    up_lim=floor(fs/f0min);  % round towards negative sample number
    k=2;
    while ((rx_index(k)<low_lim) || rx_index(k)>up_lim)
        k=k+1;
    end
    
    m=2;
    while ((d2(m)<low_lim) || d2(m)>up_lim)
        m=m+1;
    end
    ll(i)=d2(m);
    mm=d2(m); 
    HNR_dB_Praat(i) = 10*log10(rho(mm)/(1-rho(mm)));
    NHR_Praat(i) = (1-rho(mm))/rho(mm);

end

%% Summarize data
HNR(1)=mean(HNR_dB_Praat);
HNR(2)=std(HNR_dB_Praat);

NHR(1)=mean(NHR_Praat);
NHR(2)=std(NHR_Praat);

end

function [GQ] = glottis_quotient(VF_close, VF_open, fs, f0min, f0max, flag)
%% Calculate the glottis quotients

cycle_open=abs(VF_open(2:end)-VF_close(1:end-1));
cycle_closed=abs(VF_open(1:end-1)-VF_close(1:end-1));

% remove erroneous cycles
if flag
    low_lim=fs/f0max; % lower limit
    up_lim=fs/f0min;  % upper limit
    N=length(cycle_open);
    for i=1:N-1
        if((cycle_open(i) > up_lim) || (cycle_open(i) < low_lim))
            cycle_open(i)=NaN;
        end
        if((cycle_closed(i) > up_lim) || (cycle_closed(i) < low_lim))
            cycle_closed(i)=NaN;
        end
    end
end

%statistics in time
prc1=prctile(cycle_open,[5 95]);
cycle_open_range_5_95_perc=prc1(2)-prc1(1);
prc2=prctile(cycle_closed,[5 95]);
cycle_closed_range_5_95_perc=prc2(2)-prc2(1);

GQ(1) = (cycle_open_range_5_95_perc/(cycle_open_range_5_95_perc+cycle_closed_range_5_95_perc));
GQ(2) = (nanstd(cycle_open));
GQ(3) = (nanstd(cycle_closed));

end

function [GNE] = GNE_measure(data, fs)

filt_order=100;
new_fs=10000;
x = 0.03*new_fs;
tstep=0.01*new_fs;
BW = 1000; % bandwidth
Fshift = 500; % shift fr   
data = resample(data, new_fs, fs); 

% cut-off1
Fc1=1:Fshift:(new_fs/2-BW-500); % not to cross Nq freq!
% cut-off2
Fc2=Fc1+BW;

for j=1:length(Fc1);
    d(j) =fdesign.bandpass('n,fc1,fc2',filt_order,Fc1(j),Fc2(j),new_fs);
    hd(j) = design(d(j));
end

steps=(length(data)-x)/tstep;

for i=1:steps+1   
    tseries = data(1+(i-1)*tstep:(i-1)*tstep+x);
    Dwindow = hann(length(tseries));
    segment_sig = tseries.*Dwindow;

    a = lpc(segment_sig,13);
    est_x = filter([0 -a(2:end)],1,segment_sig);    % Estimated signal
    e = segment_sig - est_x;
    LPE = xcorr(e,'coeff');   % LPES
    LPE=LPE(length(LPE)/2:end);

    for ii=1:length(hd)
        sigBW(:,ii)=filter(hd(ii),LPE);
        sig_TKEO(ii) = mean(TKEO(sigBW(:,ii)));
        sig_energy(ii) = mean(sigBW(:,ii)).^2; 
    end
    Hilb_tr = hilbert(sigBW);
    Hilb_env = abs(Hilb_tr);
    c = xcorr(Hilb_env);
    [cval,cidx] = max(c);
    GNEm(i) = max(cval);
    
    signal_BW_TKEO(i,:) = sig_TKEO;  
    signal_BW_energy(i,:) = sig_energy;
end

signal_BW_TKEO2 = mean(log(signal_BW_TKEO)); % used for getting the noise to signal ratio
signal_energy2 = mean(log(signal_BW_energy));

% Set outputs

GNE(1) = mean(GNEm);
GNE(2) = std(GNEm);

gnTKEO = mean(signal_BW_TKEO);
gnSEO = mean(signal_BW_energy);
GNE(3) = sum(gnTKEO(1:2))/sum(gnTKEO(end-3:end));
GNE(4) = sum(gnSEO(1:2))/sum(gnSEO(end-3:end));
GNE(5) = sum(signal_BW_TKEO2(end-3:end))/sum(signal_BW_TKEO2(1:2));
GNE(6) = sum(signal_energy2(end-3:end))/sum(signal_energy2(1:2));

end


function [VFER] = VFER_measure(data, fs)

filt_order=100;
BW = 500; % bandwidth 
Fmax = (fs/2-BW-300); % Max frequency to check 
Fshift = 500; % shift 

% get VF action
[VF_close,VF_open] = dypsa(data,fs);

% cut-off1
Fc1=1:Fshift:Fmax;
% cut-off2
Fc2=Fc1+BW;

for j=1:length(Fc1);
    d(j) = fdesign.bandpass('n,fc1,fc2',filt_order,Fc1(j),Fc2(j),fs);
    hd(j) = design(d(j));
end

for i=1:length(VF_close)-1
    tseries = data(VF_close(i):VF_close(i+1));
    Dwindow = hann(length(tseries)); %Use Hanning window
    segment_sig = tseries.*Dwindow;
    
    if (length(tseries)>50)
        for ii=1:length(hd)
            thanasis = filter(hd(ii),segment_sig);
            sigBW(:,ii) = thanasis(1:50);
            sig_TKEO(ii) = mean(TKEO(sigBW(:,ii)));
            sig_SEO(ii) = mean(sigBW(:,ii)).^2; 
        end
        Hilb_tr = hilbert(sigBW);
        Hilb_env = abs(Hilb_tr);
        c = xcorr(Hilb_env);
        [cval,cidx] = max(c);
        NEm(i) = max(cval);

        signal_BW_TKEO(i,:) = sig_TKEO;
        signal_BW_SEO(i,:) = sig_SEO;        
    end
end

signal_BW_TKEO2 = mean(log(signal_BW_TKEO)); % used for getting the noise to signal ratio

% Set outputs

VFER(1) = mean(NEm);
VFER(2) = std(NEm);
VFER(3) = -sum(NEm.*log_bb(NEm));
VFTKEO = mean(signal_BW_TKEO);
VFSEO = mean(signal_BW_SEO);
VFlog_SEO = mean(log(signal_BW_SEO));

% Get 'signal to noise' ratios
VFER(4) = sum(VFTKEO(1:5))/sum(VFTKEO(6:10));
VFER(5) = sum(VFSEO(1:5))/sum(VFSEO(6:10));
VFER(6) = sum(signal_BW_TKEO2(6:10))/sum(signal_BW_TKEO2(1:5));
VFER(7) = sum(VFlog_SEO(6:10))/sum(VFlog_SEO(1:5));

end

function [IMF] = IMF_measure(data)

%% Use classical EMD

IMF_dec = emd(data);
IMF_dec=IMF_dec';
IMF_dec2=log_bb(IMF_dec); %Log transformation
[N,M]=size(IMF_dec);

for i=1:M
    IMF_decEnergy(i) = abs(mean((IMF_dec(:,i)).^2));
    IMF_decTKEO(i) = abs(mean(TKEO(IMF_dec(:,i))));
    IMF_decEntropia(i) = abs(mean(-sum(IMF_dec(:,i).*log_bb(IMF_dec(:,i)))));
    IMF_decEnergy2(i) = abs(mean((IMF_dec2(:,i)).^2));
    IMF_decTKEO2(i) = abs(mean(TKEO(IMF_dec2(:,i))));
    IMF_decEntropia2(i) = abs(mean(-sum(IMF_dec2(:,i).*log_bb(IMF_dec2(:,i)))));
end
    
% Get 'signal to noise' ratio measures
IMF(1) = sum(IMF_decEnergy(4:end))/sum(IMF_decEnergy(1:3));
IMF(2) = sum(IMF_decTKEO(4:end))/sum(IMF_decTKEO(1:3));
IMF(3) = sum(IMF_decEntropia(4:end))/sum(IMF_decEntropia(1:3));
IMF(4) = abs(sum(IMF_decEnergy2(1:2))/sum(IMF_decEnergy2(4:end)));
IMF(5) = abs(sum(IMF_decTKEO2(1:2))/sum(IMF_decTKEO2(3:end)));
IMF(6) = sum(IMF_decEntropia2(1:2))/sum(IMF_decEntropia2(3:end));

end

function [energy] = TKEO(x)

data_length=length(x);
energy=zeros(data_length,1);

energy(1)=(x(1))^2; % first sample in the vector sequence

for n=2:data_length-1
    energy(n)=(x(n))^2-x(n-1)*x(n+1); % classical TKEO equation
end

energy(data_length)=(x(data_length))^2; % last sample in the vector sequence

end % end of TKEO function

function H = H_entropy(f)
% Calculate entropy of a discrete distribution
% Usage: H = entropy(f)
%  f - input distribution as a vector
%  H - entropy
N = length(f);
H = 0;
for j = 1:N
   H = H - f(j) * log_bb(f(j));
end

end % end of H_entropy function

function pout = log_bb(pin, method)
% Function that computes the algorithm depending on the user specified
% base; if the input probability is zero it returns zero.

if nargin<2
    method = 'Nats';
end

switch (method)
    case 'Hartson' % using log10 for the entropy computation
        log_b=@log10;
        
    case 'Nats' % using ln (natural log) for the entropy computation 
        log_b=@log;
       
    otherwise % method -> 'Bits' using log2 for the entropy computation 
        log_b=@log2;
end

if pin==0
    pout=0;
else
    pout=log_b(pin);
end

end

##### SOURCE END #####
--></body></html>